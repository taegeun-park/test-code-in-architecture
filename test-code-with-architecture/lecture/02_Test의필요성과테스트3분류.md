### # 테스트의 필요성

### 레거시코드?

* 단순히 오래된 코드?
* 유지보수가 안되는 코드?

정의가 애매하다.

> "내게 레거시 코드란, 단순히 테스트 루틴이 없는 코드다. 다만 이정의는 다소 불완전하다"
>
> 마이클 C. 페더스

## 필요성

### Regression

잘 돌아가던 코드가 이번 배포로 인해 동작하지 않는 상황을 의미한다

이런 regression을 한두번 경험하다 보면, 전체적으로 수정과 배포가 무서워지게 된다.

> 구글 웹서버 이야기
>
> 2005년 구글 웹서버에 생산성이 급격히 떨어지는 문제 발생.
>
> 설상가상 이시기에는 릴리즈 주기도 길었고 버그도 많았음
>
> 아무리 똑똑한 엔지니어를 투입해도 문제가 해결되지 않았고, **불안에 떨며 릴리즈했음**
>
> GWS 테크 리더는 **자동 테스트를 도입**하기로 결정함
>
> 팀원들은 자신있게 배포 할 수 있게 되었고, **생산성이 올라감**

### 좋은 아키텍쳐를 유도한다

> **좋은 아키텍쳐란?**
>
> Test와 SOLID의 관계
>
> 테스트의 목적 중 하나는 회귀 버그 방지의 역할이다. SOLID를 적용하면 경계가 만들어지기때문에 회귀버그를 막을 수 있다. 이런 관점에서 TEST와 SOLID는 서로에게 영향을 준다.

### SOLID

**S**

* 단일 책임 원칙
    * 테스트는 명료하고 간단하게 작성해야하기 때문에, 단일 책임 원칙을 지키게 됨
    * 테스트가 너무 많아져서 이게 무슨 목적의 클래스인지 눈에 안들어오는 지점이 생김
    * 이 때가 클래스를 분할해야 하는 시점, 그러면서 책임이 자연스럽게 분배됨

**O**

* 개방 폐쇄 원칙
    * 테스트 컴포넌트와 프로덕션 컴포넌트를 나눠 작업하게 되고 필요에 따라 이 컴포넌트를 자유자재로 탈부착이 가능하게 개발하게

**L**

* 리스코프 치환 원칙
    * '슈퍼 클래싀의 계약을 서브 클래스가 제대로 치환하는지 확인하라'
    * 이상적으로 테스트는 모든 케이스에 대해 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해

**I**

* 인터페이스 분리 원칙
    * 테스트는 그 자체로 인터페이스를 직접 사용해 볼 수 있는 환경
    * 불필요한 의존성을 실제로 확인 할 수 있는 샌드박스

**D**

* 의존성 역전 원칙
    * 가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어 있어야 하는 경우가 생김

# 테스트의 3분류

## 전통적인 테스트 3분류

정의가 모호하다 통합테스트란? 단위테스트란? 사람마다의 정의가 다름

* E2E
    * API 테스트
* INTEGRATION
    * 통합 테스트
* UNIT
    * 단위 테스트

## 구글에서의 테스트 3분류

* E2E
    * Large 테스트
* INTEGRATION
    * Medium 테스트
* UNIT
    * Small 테스트

### Small 테스트란?

- 단일 서버
- 단일 프로세스
- 단일 스레드
- 디스크 I/O 사용 X
- Blocking call 허용 X

> 소형 테스트는 매우 중요하다 왜나하면 상단의 조건들 때문에 항상 결과가 '결정적' 이고, 테스트 속도가 빨라지기 때문이다.

### Medium 테스트란?

* 단일 서버
* 멀티 프로세스
* 멀티 스레드

멀티프로세스와 멀티 스레드를 사용 할 수 있다

=> h2 같은 테스트용 DB를 사용할 수 있게 된다는 의미

=> h2를 사용한 테스트는 소형 테스트가 아님

> 소형 테스트보다 느리고, 멀티스레드 환경에서 어떻게 동작할지 모르게 때문에, 결과가 항상 같다고 보장 할 수 없다.
> 테스트 결과가 h2 같은 외부 모듈의 동작에 따라 달라지기 때문,

**스프링 개발자들이 많이 하는 실수?**

-> 중형 테스트를 많이 만드는 실수

모든 테스트가 h2를 사용하도록 만드는 경우가 많음

=> 소형테스트가 전체 테스트의 80% 정도를 차지해야 좋은 테스트라 할 수 있다.

### Large 테스트란?

* 멀티 서버
* End to end 테스트

 