 # 빌더

 빌더 패턴은 객체 생성이 다양해지는 문제를 해결하기 위해 마련된 유동적인 해결책

 다른말로, 생성자가 지나치게 많아지는 문제를 해결할 수 있는 유연한 해결책 이다.

 > 빌더패턴은 개발자가 일부 파라미터를 누락하게 하는 실수를 만들기도 한다.
 >
 > (일반 생성자를 사용했다면, 컴파일 에러가 났을 거임)

 그럼에도 빌더를 좋아하는 이유

 1. 새 객체를 생성할 때 문법적으로 지저분한 부분을 가려준다.
 2. 기본적인 경우를 단순하게 하고 특별한 경우라도 그리 복잡하게 만들지 않는다.
 3. 테스트 객체의 구조적인 변화로부터 테스트를 다시 한 번 보호한다.

 ...

 4. 마지막 이점은 읽기 쉽고 오류를 찾기 쉬운 테스트 코드를 작성 할 수 있다는 것이다.
    각 빌더 메서드가 해당 매개변수의 용도를 밝히기 때문에



 # 엔티티

 ## 엔티티에 대한 잘못된 오해

 * 엔티티는 JPA와 상관이 없다.
   * 하지만 이게 마냥 틀린설명은 아니다.
   * 오라클에서도 도메인 엔티티와 DB 엔티티의 개념을 섞어서 설명하고 있기 때문이다.
   * 하지만 도메인 엔티티와 DB 엔티티는 다르다

 > 경력을 더할수록 도메인 모델에 대한 이해가 쌓이면서 실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은 것이 아님을 알게 되었다.
 > -최범균, DDD START! 도메인 주도 설계 구현과 핵심 개념 익히기 55p-

 ## 엔티티의 구분

 ### 도메인 엔티티

 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델

 비즈니스 로직을 들고 있고, 식별 가능하며, 일반적으로 생명주기를 갖는다.

 ### DB 엔티티

 데이터베이스 업계에서 원래 쓰던 용어

 데이터베이스 분야에서 개체 또는 엔티티라고 하는 것은 데이타베이스에 표현하려고 하는 유형, 무형의 객체로써 서로 구별되는 것을 뜻한다.

 ### 개인적인 해석

 * 초기의 객체 지향 분야와 데이터베이스 분야에서 비슷한 고민을 갖고 어떤 문제를 해결하기 위해 노력했다.
 * 그리고 이대 둘 다 엔티티라는 용어를 사용했는데, 해결책이 미묘하게 달랐다.
 * 객체지향 진영에서는 클래스로 표현이 되었고
 * 데이터베이스 진영에서는 테이블로 표현이 되었다.
 * 실제로 생김새도 꽤나 비슷하다.
 * 그런데 실세계에서 서비스를 만들려면 양쪽이 협업을 해야한다.
 * 그래서 DB 엔티티에 있는 값을 도매인 엔티티로 옮겨야 할 필요가 있었고, 그게 영속성 객체, JPA 라고 보면된다.

 ### 정리

 * 도메인 엔티티 ---- 비즈니스 영역을 해결하는 모델
 * 영속성 객체 ------------ ORM ( Object Relational Mapping)
 * DB 엔티티 ----------------- RDB에 저장되는 객체



 도메인 엔티티에 JPA 어노테이션이 붙는 걸 반대한다.

 도메인 엔티티에 JPA 어노테이션이 붙는 순간 우리 시스템이 RDB에 종속된다는 의미이기 때문이다.

 RDB를 사용하지 않고 ,mongoDB를 사용한다면?



 # 기타 조언

 ### private 메소드는 테스트 하지 않아도 된다.

  "http://shoulditestprivatemethods.com"

 사이트 페이지 주석

 -> private 메소드를 테스트하고 싶은 느낌이 든다면, 사실 private 메소드가 아니어야 한다는 의미이거나,
 다른 클래스로 분리/책임을 위임하여 public 으로 만들라는 신호이다.

 ### final 메소드를 stub하는 상황을 피해야 한다.

 * final 메소드를 stub 해야하는 상황이 생긴다면, 설계가 잘못된 것이다.



 ### DRY < DAMP

 * DRY : Don't repat yourself
   * 코드 중복을 피해라!
 * 반대로 테스트 할때는 DAMP(습한)
   * 테스트 할 때 만큼은 중복이 되더라도 가독성 좋은것이 낫다는 의미
   *

 ### 테스트에서는 논리로직을 피해라

 * 테스트에 논리를 넣지 말자 (+, for, if ...)